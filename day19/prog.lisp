;; day 19

(ql:quickload :cl-ppcre)
(ql:quickload :split-sequence)
(ql:quickload :lisp-utils)
(ql:quickload :alexandria)

(use-package :lisp-utils)
(use-package :cl-ppcre)

(defun parse-parts (lines)
  (let* ((sections (split-sequence-into-sections lines)))
    (mapcar (lambda (line)
              (let ((vals (cl-ppcre:split "," (string-trim '(#\{ #\}) line)))
                    (part (make-hash-table :test #'equal)))
                (loop for val in vals
                      do (let* ((chunks (cl-ppcre:split "=" val))
                                (key (first chunks))
                                (value (parse-integer (second chunks))))
                           (setf (gethash key part) value)))
                part))
            (cadr sections))))

(defclass step ()
  ((var-name :initarg :var-name :accessor var-name :initform nil)
   (op :initarg :op :accessor op :initform nil)
   (value :initarg :value :accessor value :initform nil)
   (dest :initarg :dest :accessor dest)))

(defun make-step (var-name op value dest)
  (make-instance 'step
                 :var-name var-name
                 :op op
                 :value (parse-integer value)
                 :dest dest))

(defmethod print-object ((obj step) stream)
  (print-unreadable-object (obj stream :type t)
    (with-accessors ((var-name var-name)
                     (op op)
                     (value value)
                     (dest dest))
        obj
      (format stream "~a, ~a, ~a, ~a" var-name op value dest))))
 
(defun parse-rules (lines)
  (let* ((sections (split-sequence-into-sections lines))
         (workflows (make-hash-table :test #'equal)))
    (loop for line in (car sections)
          do (let* ((lb-pos (position #\{ line))
                    (rb-pos (position #\} line))
                    (wf-name (subseq line 0 lb-pos))
                    (wf-steps (cl-ppcre:split "," (subseq line (1+ lb-pos) rb-pos)))
                    (steps nil))
               (dolist (step wf-steps)
                 (if (position #\: step)
                     (let* ((rule-chunks (cl-ppcre:split ":" step))
                            (dest (cadr rule-chunks))
                            (rule-match (multiple-value-bind (whole groups)
                                            (cl-ppcre:scan-to-strings "(\\w+)([<>])(\\d+)" (car rule-chunks))
                                          groups)))
                       (if rule-match
                           (let ((step (make-step (aref rule-match 0)
                                                  (aref rule-match 1)
                                                  (aref rule-match 2)
                                                  dest)))
                             (push step steps))
                           (let ((step (make-instance 'step :dest dest)))
                             (push step steps))))
                     (let ((step (make-instance 'step :dest step)))
                       (push step steps))))
               (setf (gethash wf-name workflows) (nreverse steps))))
    workflows))

(defun part1 (file-name)
  (let* ((lines (uiop:read-file-lines file-name))
         (accepted nil)
         (rejected nil)
         (workflows (parse-rules lines))
         (parts (parse-parts lines)))
    (dolist (part parts)
      (print part)
      (let* ((workflow (gethash "in" workflows)))
        (loop while workflow
              do (dolist (step workflow)
                   (let* ((switch-to nil)
                          (end nil)
                          (var-name (var-name step)))
                     (cond ((not (null var-name))
                            (if (equal (op step) "<")
                                (if (< (gethash var-name part) (value step))
                                    (cond ((equal (dest step) "R")
                                           (push part rejected)
                                           (setf end t))
                                          ((equal (dest step) "A")
                                           (push part accepted)
                                           (setf end t))
                                          (t (setf switch-to (dest step)))))
                                (if (> (gethash var-name part) (value step))
                                    (cond ((equal (dest step) "R")
                                           (push part rejected)
                                           (setf end t))
                                          ((equal (dest step) "A")
                                           (push part accepted)
                                           (setf end t))
                                          (t (setf switch-to (dest step)))))))
                           ((equal (dest step) "R")
                            (push part rejected)
                            (setf end t))
                           ((equal (dest step) "A")
                            (push part accepted)
                            (setf end t))
                           (t (setf switch-to (dest step))))
                     (when switch-to
                       (setf workflow (gethash switch-to workflows))
                       (return))
                     (when end
                       (setf workflow nil)
                       (return)))))))
    (reduce #'+ (mapcar (lambda (part)
                          (let ((sum 0))
                            (maphash (lambda (key value)
                                       (format t "~&~a: ~a~%" key value)
                                       (incf sum value))
                                     part)
                            sum))
                        accepted))))

(print (part1 "input0.txt"))
(print (part1 "input1.txt"))


