;; day 19

(ql:quickload :cl-ppcre)
(ql:quickload :split-sequence)
(ql:quickload :lisp-utils)
(ql:quickload :alexandria)

(use-package :lisp-utils)
;;(use-package :cl-ppcre)

(defun parse-parts (lines)
  (let* ((sections (split-sequence-into-sections lines)))
    (mapcar (lambda (line)
              (let ((vals (cl-ppcre:split "," (string-trim '(#\{ #\}) line)))
                    (part (make-hash-table :test #'equal)))
                (loop for val in vals
                      do (let* ((chunks (cl-ppcre:split "=" val))
                                (key (first chunks))
                                (value (parse-integer (second chunks))))
                           (setf (gethash key part) value)))
                part))
            (cadr sections))))

(defclass step ()
  ((var-name :initarg :var-name :accessor var-name :initform nil)
   (op :initarg :op :accessor op :initform nil)
   (value :initarg :value :accessor value :initform nil)
   (dest :initarg :dest :accessor dest)))

(defun make-step (var-name op value dest)
  (make-instance 'step
                 :var-name var-name
                 :op op
                 :value (parse-integer value)
                 :dest dest))

(defmethod print-object ((obj step) stream)
  (print-unreadable-object (obj stream :type t)
    (with-accessors ((var-name var-name)
                     (op op)
                     (value value)
                     (dest dest))
        obj
      (format stream "~a, ~a, ~a, ~a" var-name op value dest))))
 
(defun parse-rules (lines)
  (let* ((sections (split-sequence-into-sections lines))
         (workflows (make-hash-table :test #'equal)))
    (loop for line in (car sections)
          do (let* ((lb-pos (position #\{ line))
                    (rb-pos (position #\} line))
                    (wf-name (subseq line 0 lb-pos))
                    (wf-steps (cl-ppcre:split "," (subseq line (1+ lb-pos) rb-pos)))
                    (steps nil))
               (dolist (step wf-steps)
                 (if (position #\: step)
                     (let* ((rule-chunks (cl-ppcre:split ":" step))
                            (dest (cadr rule-chunks))
                            (rule-match (multiple-value-bind (whole groups)
                                            (cl-ppcre:scan-to-strings "(\\w+)([<>])(\\d+)" (car rule-chunks))
                                          groups)))
                       (if rule-match
                           (let ((step (make-step (aref rule-match 0)
                                                  (aref rule-match 1)
                                                  (aref rule-match 2)
                                                  dest)))
                             (push step steps))
                           (let ((step (make-instance 'step :dest dest)))
                             (push step steps))))
                     (let ((step (make-instance 'step :dest step)))
                       (push step steps))))
               (setf (gethash wf-name workflows) (nreverse steps))))
    workflows))

(defun part1 (file-name)
  (let* ((lines (uiop:read-file-lines file-name))
         (accepted nil)
         (rejected nil)
         (workflows (parse-rules lines))
         (parts (parse-parts lines)))
    (dolist (part parts)
      (print part)
      (let* ((workflow (gethash "in" workflows)))
        (loop while workflow
              do (dolist (step workflow)
                   (let* ((switch-to nil)
                          (end nil)
                          (var-name (var-name step)))
                     (cond ((not (null var-name))
                            (if (equal (op step) "<")
                                (if (< (gethash var-name part) (value step))
                                    (cond ((equal (dest step) "R")
                                           (push part rejected)
                                           (setf end t))
                                          ((equal (dest step) "A")
                                           (push part accepted)
                                           (setf end t))
                                          (t (setf switch-to (dest step)))))
                                (if (> (gethash var-name part) (value step))
                                    (cond ((equal (dest step) "R")
                                           (push part rejected)
                                           (setf end t))
                                          ((equal (dest step) "A")
                                           (push part accepted)
                                           (setf end t))
                                          (t (setf switch-to (dest step)))))))
                           ((equal (dest step) "R")
                            (push part rejected)
                            (setf end t))
                           ((equal (dest step) "A")
                            (push part accepted)
                            (setf end t))
                           (t (setf switch-to (dest step))))
                     (when switch-to
                       (setf workflow (gethash switch-to workflows))
                       (return))
                     (when end
                       (setf workflow nil)
                       (return)))))))
    (reduce #'+ (mapcar (lambda (part)
                          (let ((sum 0))
                            (maphash (lambda (key value)
                                       (format t "~&~a: ~a~%" key value)
                                       (incf sum value))
                                     part)
                            sum))
                        accepted))))

(defclass span ()
  ((start :initarg :start :accessor start)
   (end :initarg :end :accessor end)))

(defmethod print-object ((obj span) stream)
  (print-unreadable-object (obj stream :type t)
    (with-accessors ((start start)
                     (end end))
        obj
      (format stream "start: ~a, end: ~a" start end))))

(defmethod len ((obj span))
  (with-slots (start end) obj
    (1+ (- end start))))

(defmethod split ((obj span) n)
  (with-slots (start end) obj
    (if (or (< n start)
            (>= n end))
        (error "n is not in range"))
    (list (make-span start (1- n))
            (make-span n end))))

(defun make-span (start end)
  (make-instance 'span :start start :end end))

(defun combos (workflows dest spans)
  (cond ((equal dest "A")
         (print "A")
         (reduce #'* (mapcar (lambda (s) (len s)) spans)))
        ((equal dest "R")
         (print "R")
         0)
        (t
         (let* ((flow (gethash dest workflows))
                (span-index (alexandria:plist-hash-table '("x" 0 "m" 1 "a" 2 "s" 3) :test #'equal)))
           (loop for step in (take flow (1- (length flow)))
                 for span = (nth (gethash (var-name step) span-index) spans)
                 collecting
                 (cond ((or (and (equal (op step) "<")
                                 (>= (start span) (value step)))
                            (and (equal (op step) ">")
                                 (< (end span) (value step))))
                        (print "pass"))
                       ((or (and (equal (op step) "<")
                                 (< (end span) (value step)))
                            (and (equal (op step) ">")
                                 (> (start span) (value step))))
                        (return (combos workflows (dest step) spans)))
                       ((equal (op step) "<")
                        (destructuring-bind (fst snd) (split span (value step))
                          (let* ((lower-spans (copy-seq spans))
                                 (upper-spans (copy-seq spans)))
                            (setf (nth (gethash (var-name step) span-index) lower-spans) fst)
                            (setf (nth (gethash (var-name step) span-index) upper-spans) snd)
                            (return (+ (combos workflows (dest step) lower-spans)
                                       (combos workflows dest upper-spans))))))
                       ((equal (op step) ">")
                        (destructuring-bind (fst snd) (split span (value step))
                          (let* ((lower-spans (copy-seq spans))
                                 (upper-spans (copy-seq spans)))
                            (setf (nth (gethash (var-name step) span-index) lower-spans) fst)
                            (setf (nth (gethash (var-name step) span-index) upper-spans) snd)
                            (return (+ (combos workflows dest lower-spans)
                                       (combos workflows (dest step) upper-spans))))))))
           (combos workflows (dest (car (last flow))) spans)))))

(print (part2 "input0.txt"))

(let ((s (make-span 1 4000)))
  (print s)
  (print (split s 2000))
  (destructuring-bind (fst snd) (split s 2000)
    (print fst)
    (print snd)))

(defun part2 (file-name)
  (let* ((lines (uiop:read-file-lines file-name))
         (workflows (parse-rules lines)))
    (combos workflows "in" (list (make-span 1 4000)
                                 (make-span 1 4000)
                                 (make-span 1 4000)
                                 (make-span 1 4000)))))





(print (part1 "input0.txt"))
(print (part1 "input1.txt"))


